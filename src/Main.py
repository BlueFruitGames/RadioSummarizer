import logging
import os 
import glob
from AudioPreprocessing import trim_audio, change_rate, setup_logging_preprocessing
from RadioSummarizer import speech_to_text, setup_logging_summarizer, setup_models
import argparse

intermediate_dir = "intermediate"

def setup_logging(log_level):
    """Sets up the logger for this module

    Args:
        log_level (str): the selected loglevel
    """
    global logger 
    logger = logging.getLogger('Main')
    logger.propagate = False
    ch = logging.StreamHandler()
    if log_level == "INFO":
        logger.setLevel(logging.INFO)
        ch.setLevel(logging.INFO)
    elif log_level == "DEBUG":
        logger.setLevel(logging.DEBUG)
        ch.setLevel(logging.DEBUG)
    formatter = logging.Formatter('%(levelname)s:%(name)s: %(message)s')
    ch.setFormatter(formatter)
    logger.addHandler(ch)
    setup_logging_preprocessing(log_level)
    setup_logging_summarizer(log_level)

def setup_args():
    """Sets up the flag arguments used by the application

    Returns:
        argparse.Namespace: Contains the arguments provided by the user
    """
    parser = argparse.ArgumentParser()
    parser.add_argument("-b", "--begin", dest = "begin_sounds_dir", help="Directory with sounds played at the begining")
    parser.add_argument("-c", "--min_correlation", dest = "min_correlation", default = -1, help="filter value for trim correlation")
    parser.add_argument("-d", "--delete", dest = "delete", action='store_true', help="Delete contents of intermediate Directory?")
    parser.add_argument("-db", "--debug", dest = "debug", action='store_true', help="Show debug information?")
    parser.add_argument("-e", "--end", dest = "end_sounds_dir", help="Directory with sound played at the ending")
    parser.add_argument("-i", "--input",dest ="input", help="Audiofile/or Directory of files to convert")
    parser.add_argument("-l", "--language",dest ="language", default="de", help="Language used in the audiofile")
    parser.add_argument("-o", "--output_dir", dest = "output_dir", default = "output", help="Output directory")
    parser.add_argument("-t", "--trimfile", dest = "trimfile", action='store_true', help="Trim the audio file before conversion?")
    return parser.parse_args()

def does_path_exist(current_path, name):
    """Checks if the provided path exists

    Args:
        current_path (str): the path to check
        name (str): name of the input argument
    """
    if not os.path.exists(current_path):
        logger.error("{} doesn't exist".format(name))
        exit()
        
def check_args(args):
    """Reads the arguments provided by the user

    Args:
        args (argparse.Namespace): The args generated by setup_args()

    Returns:
        str: language_code
        str: path to source file
        bool: if file should be trimmed 
        int: value of the minimum correlation for trimming files
        str: path to the directory with the sound samples of the beginning of a broadcast
        str: path to the directory with the sound samples of the end of a broadcast
        str: path to the output directory 
        bool: if contents of intermediate directory should be deleted
    """
    #Reads the input of the -db flag
    is_debug = args.debug
    log_level = "INFO"
    if is_debug:
        log_level = "DEBUG"
    setup_logging(log_level)
    
    #Reads the input of the -i flag
    if(args.input == None):
        logger.error("No source file provided!")
        exit()
    source_path = args.input
    does_path_exist(source_path, "SourceFile")
    
    #Reads the input of the -t
    trim_file = args.trimfile
    
    #Reads the input of the -b flag
    if(trim_file and args.begin_sounds_dir == None):
        logger.error("No file with begin sound provided!")
        exit()
    begin_sounds_dir = args.begin_sounds_dir
    if trim_file:
        does_path_exist(begin_sounds_dir, "BeginSoundDir")
    
    #Reads the input of the -e flag
    if(trim_file and args.end_sounds_dir == None):
        logger.error("No directory with end sounds provided!")
        exit()
    end_sounds_dir = args.end_sounds_dir
    if trim_file:
        does_path_exist(end_sounds_dir, "EndSoundDir")
       
    #Reads the input of the -c flag    
    min_correlation = int(args.min_correlation)
    
    #Reads the input of the -d flag
    delete_intermediate = args.delete
    
    #Reads the input of the -l flag
    language = args.language    

    #Reads the input of the -o flag
    output_dir = args.output_dir
    does_path_exist(output_dir, "OutputDir")
    if os.path.isfile(output_dir): 
        logger.error("Entered file as output directory")
        exit()

    return language, source_path, trim_file, min_correlation, begin_sounds_dir, end_sounds_dir, output_dir, delete_intermediate
 
#Handling of program arguments   
args = setup_args()
language, source_path, trim_file, min_correlation, begin_sounds_dir, end_sounds_dir, output_dir, delete_intermediate = check_args(args)
intermediate_dir_path = os.path.join(output_dir, intermediate_dir)
if not os.path.exists(intermediate_dir_path):
    os.makedirs(intermediate_dir_path)

source_files = []
wav_files = []
if os.path.isfile(source_path):
    if ".mp3" in source_path:
        source_files.append(source_path)
    elif ".wav" in source_path:
        wav_files.append(source_path)
else:
    for file in glob.glob(os.path.join(source_path, "*")):
        if ".mp3" in file:
            source_files.append(file)
        elif ".wav" in file:
            wav_files.append(file)     

if len(source_files) == 0 and len(wav_files) == 0:
    logger.error("No valid source audio/s provided!")
    exit()    


#Trimming and Conversion of the source file
logger.info("Preparing audiofiles...")
trimmed_count = 0
trimmed_files = []
for file in source_files:
    if trim_file:    
        is_trimmed, trimmed_file = trim_audio(file, begin_sounds_dir, end_sounds_dir, intermediate_dir_path, min_correlation)
        if is_trimmed:
            trimmed_files.append(trimmed_file)
            trimmed_count += 1            
    else:   
        trimmed_files.append(change_rate(file, intermediate_dir_path))
        
if trim_file:
    if trimmed_count == 1:
        logger.info("{} of {} was successfully trimmed.".format(trimmed_count, len(source_files)))
    else:
        logger.info("{} of {} were successfully trimmed.".format(trimmed_count, len(source_files)))

if len(trimmed_files) == 0 and len(wav_files) == 0:
    logger.error("No files for conversion!")
    exit()
    
files_to_convert = trimmed_files + wav_files
#Conversion of audio to text 
setup_models(language)
for file in files_to_convert:
    file_name = os.path.basename(file)
    logger.info("Starting conversion of {}".format(file_name))
    output_file = os.path.join(output_dir, os.path.basename(file).replace(".wav", ".txt"))
    speech_to_text(file, output_file)

#Deletion of contents in the intermediate folder
if delete_intermediate:
    logger.info("Deleting files in Intermediate directory...")
    files = glob.glob(intermediate_dir_path + "/*")
    for file in files:
        os.remove(file)

logger.info("Speech to text conversion finished!")